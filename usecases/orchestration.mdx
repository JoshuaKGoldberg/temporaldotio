import MDXProvider from './_mdxprovider';
export const meta = {
  title: 'Markdown/MDX with Next.js',
  author: 'Lee Robinson'
};
export default ({ children, slugPrefix }) => (
  <MDXProvider {...{ meta, slugPrefix }}>{children}</MDXProvider>
);

## Motivation

It is common to break a large application into **microservices** structured around the application's distinct business capabilities:

- Each microservice is owned by separate teams who make their own technology choices and release processes.
- Each microservice typically has its own storage and interacts with other services via a well-defined API.
- Application/Product developers need to call multiple microservices to achieve the desired outcome.
- Every time you cross a system boundary, your chance of failure multiplies.
- Product developers spend a lot of effort implementing queues, timeouts and retries to ensure that API calls eventually succeed, preserving business rules across multiple independent sub-domains.
- Service interdependencies can be remarkably complicated. Processes can run asynchronously or in parallel, some tasks need information from other systems, and the next steps often depend on the outcome of previous Activities.

## Benefits

Temporal solves this by providing a central orchestrator providing "**reliability on rails**" to every team.

- **Retries, Timeouts, Sagas**: It guarantees that Workflow code eventually completes, has built-in support for exponential Activity **retries**, and simplifies the coding of the **compensation** logic with native [Saga pattern support](#distributed-transactions). You can define retries, rollbacks, or even a human intervention step in the case of failure.
- **Workflows as Code**: Workflows are defined in general-purpose programming languages (Go, Java, PHP, and TypeScript/JavaScript) that bring the ultimate **flexibility** especially when compared to text-based DSL engines.
- **Observability**: Temporal tracks the entire event history of each Workflow's state. Contrast this with ad-hoc orchestration based on queues where getting a current status of each request is virtually impossible.
- **Scale**: Temporal seamlessly scales to a large number of Workflows running in parallel.

## Further Reading

- [Orchestration vs Choreography](https://theburningmonk.com/2020/08/choreography-vs-orchestration-in-the-land-of-serverless/)

Here are two real-world examples of Temporal-powered service orchestration scenarios:

- [Using Temporal Workflows to spin up Kubernetes](https://banzaicloud.com/blog/introduction-to-cadence/) by Banzai Cloud
- Improving the User Experience with Uberâ€™s [Customer Obsession Ticket Routing Workflow and Orchestration Engine](https://eng.uber.com/customer-obsession-ticket-routing-workflow-and-orchestration-engine/)
